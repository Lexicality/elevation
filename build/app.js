(function(e){"use strict";class o extends unobservable.Observable{constructor(e,o){super();this.elevator=e;this.direction="stopped";this.upQueue=new Set;this.downQueue=new Set;this.activeQueue=new Set;e.on("idle",this.onIdle.bind(this));e.on("floor_button_pressed",this.onFloorRequest.bind(this));e.on("passing_floor",this.onPassFloor.bind(this));e.on("stopped_at_floor",this.onArrive.bind(this))}get floor(){return this.elevator.currentFloor()}get realDirection(){return this.elevator.destinationDirection()}lights(){this.elevator.goingDownIndicator(this.direction=="down");this.elevator.goingUpIndicator(this.direction=="up")}updateQueue(){if(this.direction=="up"){this.elevator.destinationQueue.sort(((e,o)=>e-o))}else{this.elevator.destinationQueue.sort(((e,o)=>o-e))}this.elevator.checkDestinationQueue()}goToFloor(e){console.info("GOTO (%s %d): %d",this.direction,this.floor,e);if(this.direction!="stopped"){throw new Error("You should be stopped when calling this!!")}if(e==this.floor){console.error("asked to go to the floor we're currently on?")}this.elevator.goToFloor(e)}requestGoingUp(e){console.info("REQ UP (%s %d): %d",this.direction,this.floor,e);let o=this.direction;if(o=="stopped"){console.log("not moving, serving directly");this.goToFloor(e);this.direction="up";this.lights()}else if(o=="down"){console.log("we're going in the other direction, ignoring");this.upQueue.add(e)}else if(e<=this.floor){console.log("that's a request for below us, ignoring for now");this.upQueue.add(e)}else if(this.activeQueue.has(e)){console.log("already going there!")}else{console.log("adding to queue");this.elevator.destinationQueue.push(e);this.updateQueue()}}requestGoingDown(e){console.info("REQ DOWN (%s %d): %d",this.direction,this.floor,e);let o=this.direction;if(o=="stopped"){console.log("not moving, serving directly");this.goToFloor(e);this.direction="down";this.lights()}else if(o=="up"){console.log("we're going in the other direction, ignoring");this.downQueue.add(e)}else if(e>=this.floor){console.log("that's a request for above us, ignoring for now");this.downQueue.add(e)}else if(this.activeQueue.has(e)){console.log("already going there!")}else{console.log("adding to queue");this.elevator.destinationQueue.push(e);this.updateQueue()}}onIdle(){console.info("IDLE (%s %d)",this.direction,this.floor);let e=this.direction;if(e=="up"&&this.downQueue.size>0){this.activeQueue=new Set(this.downQueue);this.elevator.destinationQueue=Array.from(this.downQueue);this.downQueue=new Set;this.direction="down";this.updateQueue()}else if(e=="down"&&this.upQueue.size>0){this.activeQueue=new Set(this.upQueue);this.elevator.destinationQueue=Array.from(this.upQueue);this.upQueue=new Set;this.direction="up";this.updateQueue()}else if(this.downQueue.size>0){this.activeQueue=new Set(this.downQueue);this.elevator.destinationQueue=Array.from(this.downQueue);this.downQueue=new Set;this.direction="down";this.updateQueue()}else if(this.upQueue.size>0){this.activeQueue=new Set(this.upQueue);this.elevator.destinationQueue=Array.from(this.upQueue);this.upQueue=new Set;this.direction="up";this.updateQueue()}else{this.direction="stopped"}this.lights();console.log("Was going %s, going to go %s now",e,this.direction);console.dir(this.elevator.destinationQueue)}onFloorRequest(e){console.info("INT REQ (%s %d): %d",this.direction,this.floor,e);let o=this.floor;if(e<o){console.log("request for below, treating as a down req");this.requestGoingDown(e);return}else if(e>o){console.log("request for above, treating as an up req");this.requestGoingUp(e);return}console.warn("request for current floor");let t=this.direction;if(t=="stopped"){console.warn("?? not moving");this.goToFloor(e)}else if(t=="up"){console.log("?? can't stop at this floor any more, treating as down");this.requestGoingDown(e)}else{console.log("?? can't stop at this floor any more, treating as up");this.requestGoingUp(e)}}onPassFloor(e,o){console.info("PASS (%s %d): %d %s",this.direction,this.floor,e,o)}onArrive(e){console.log("ARRIVE (%s %d): %d",this.direction,this.floor,e);this.activeQueue.delete(e)}}class t{constructor(){this.elevators=[]}init(e,t){e.forEach((e=>{this.elevators.push(new o(e,t))}));t.forEach(((e,o)=>{e.on("up_button_pressed",(()=>this.elevators.forEach((e=>e.requestGoingUp(o)))));e.on("down_button_pressed",(()=>this.elevators.forEach((e=>e.requestGoingDown(o)))))}))}update(e,o,t){}}let i=new t;const s=i.init.bind(i);const n=i.update.bind(i);e.init=s;e.update=n;Object.defineProperty(e,"__esModule",{value:true});return e})({});
